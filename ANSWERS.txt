Q 1-1: Why use -e flags over ENV in a Dockerfile for secrets?

Using ENV in a Dockerfile hard-codes the secret (like a password) into the image layer. This means anyone who gets the image can inspect it and find the secret.

Using the -e flag at runtime injects the secret only when the container starts. The secret is not saved in the image, making it much more secure and reusable.


____________________________________________________________________________________________________________________________________________________


Q 1-2: Why use a volume for the database?

Containers are ephemeral (temporary) by design. When a container is removed, its internal filesystem is destroyed.

A database must persist data permanently. By attaching a volume to the container's data directory (like /var/lib/postgresql/data), we store the data on the host machine, outside the container. If the container is deleted, the data remains safe in the volume and can be attached to a new container.



Q 1-3: Database Service Documentation

This service runs the PostgreSQL database for our application.

(database/Dockerfile)

FROM postgres:17.2-alpine
Copy initialization scripts
COPY ./init/ /docker-entrypoint-initdb.d/


### Build Command
To build the image from the root directory: docker build -t tp1/database database/

Run Command
This command runs the database container with a persistent volume and connects it to the network.

docker network create app-network


Run container
docker run -d

--name db

--network app-network

-e POSTGRES_DB=db

-e POSTGRES_USER=usr

-e POSTGRES_PASSWORD=pwd

-v db-data:/var/lib/postgresql/data

____________________________________________________________________________________________________________________________________________________


Q 1-4: Why use a multistage build?

Multistage builds dramatically reduce the final image size.

We need heavy tools like Maven and the full JDK to build the application, but we only need the lightweight JRE (Java Runtime Environment) to run it.

A multistage build uses a "build" stage container with all the heavy tools. Once the application is compiled (into a .jar file), it copies only that file into a clean, lightweight "run" stage container. This keeps the final image small, secure, and fast.

Dockerfile Explanation:

FROM eclipse-temurin:21-jdk-alpine AS myapp-build: Defines the first stage named myapp-build, using a full JDK to compile code.

RUN apk add --no-cache maven: Installs the Maven build tool.

COPY pom.xml . & RUN mvn dependency:go-offline: Copies the dependency file and downloads all libraries. This is done before copying source code to cache the dependencies.

COPY src ./src & RUN mvn package -DskipTests: Copies the application source code and builds the .jar file.

FROM eclipse-temurin:21-jre-alpine: Starts the second (final) stage, using a lightweight JRE image.

COPY --from=myapp-build ...: This is the key. It copies the built .jar file from the first stage (myapp-build) into this new, clean stage.

ENTRYPOINT ["java", "-jar", "myapp.jar"]: Sets the default command to run when the container starts.



tp1/database